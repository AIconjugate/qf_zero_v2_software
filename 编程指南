
#  概要:
#      操作系统:FreeRtos
#      图形库:LVGL8.3
#      APP运行于CORE 0
#      GUI运行于CORE 1
#      请严格遵守
#      FreeRtos和ESP-IDF的编程自行学习相关内容,这里不再赘述
#      总结一些需要注意的点

#  底层APP:
#      1)如果是系统级底层APP,可以通过调用devices_interfaces的API进行相关封装
#      2)仅作为应用层面的APP,不建议调用除了system_app以外的任何底层接口,使用key_value建立通信去除耦合性
#      3)底层APP务必做好性能和内存占用的优化,尽量在需要时再申请内存,空闲时释放

#  带GUI的APP:
#      1)格式规范一定要按照app_manage库来进行标准的注册使用等流程,不要占用资源,使用完后主动释放给其他APP使用
#      2)APP的GUI部分应当在APP加载(load)时才动态创建,在切到后台(close)时删除GUI相关内容,此做法是为了利用不多的SRAM作为绘图缓存,提供更流畅的UI交互体验
#      3)因采用双核多线程编程,LVGL本身不支持多线程,固GUI部分采用如下编写方式避免出现致命错误:
#          在对LVGL的控件进行create和del时,应当先使用
#              1)system_app提供的接口system_take_gui_key()
#              2)通过获取GUI修改权限的键值对事件(推荐,可以避免耦合)
#              获取GUI修改权限后再进行创建和删除操作,否则将出现宕机
#      4)LVGL的控件内部数据的刷新,应当采用LVGL提供的lv_timer进行相关定时进行更新
#         如果实在避免不了三方函数刷新LVGL控件的内容,那么也需要使用3)中的额获取GUI修改权限的步骤后再进行修改,否则存在宕机的风险
#      5)外部获取了修改GUI权限后,应当快速使用完毕后归还权限(权限未归还期间GUI将停止更新)

#  API:
#      包含system_app头文件后,几乎可以调用框架内的所有可用API,更具体的一些目录说明,请查阅工程内的其他说明文档
#      对系统的一些操作,可通过键值对文档进行键值对通信(推荐),也可包含system_app头文件调用相关接口(不推荐存在耦合)
#      在根目录的  目录说明   文档内,包含一些可能会用到的API库的说明

#  注意:
#      ESP32S3在每次睡眠后,高速RAM内的数据都会丢失,程序重新从app_main运行,所以每一次休眠唤醒都类似于重启一样

#      如何做到休眠数据保持:
#          1)片上的快速、慢速RTC RAM都可以休眠保持数据,一些简单的标志位、个别变量等,可以申请在这两块内存当中,唤醒后copy到高速RAM使用,
#              在休眠(kill app)时将数据copy回RTC RAM进行存档,这样就能简单高效地做到休眠保持数据
#          2)对于需要大量数据保持的场景,后续开发相关接口用于数据保存同步,开发者应当尽量避免更改写入数据次数,延长FLASH使用寿命

#      如何做到关机掉电保存数据:
#          1)在关机前,系统会调用APP的power_off回调函数,APP可以在此函数内将自己的掉电保存数据存储到EEPROM,开机时再读取出来即可
    
#      如何判断是唤醒是上电唤醒(数据需要从EEPROM读出)还是休眠唤醒(数据可以从RTC RAM同步):
#          1)system_app内提供接口,用户程序开机后可自行调用接口判断

#  如何提高系统效率:
#      1)在系统唤醒后,如果APP无需后台运行任务,则无需init函数进行初始化,在load函数里添加初始化代码即可
#      2)在APP切至后台时,停掉一切不必要的任务
